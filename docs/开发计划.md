# AI 游戏开发公司 —— 完整开发计划

> **项目代号**：AI Game Studio  
> **目标**：构建一个可视化的 AI 多智能体协作平台，模拟一家真实的游戏开发公司。AI 员工（Agent）能够自由交流、协作开发游戏，用户作为观察者和决策者参与其中。  
> **开发环境**：Cursor IDE（所有代码由 Cursor AI 编写）  
> **创建日期**：2026-02-11

---

## 目录

1. [项目愿景](#1-项目愿景)
2. [系统架构总览](#2-系统架构总览)
3. [技术选型](#3-技术选型)
4. [Agent 角色设计](#4-agent-角色设计)
5. [核心机制设计](#5-核心机制设计)
6. [前端可视化设计](#6-前端可视化设计)
7. [游戏开发工作流](#7-游戏开发工作流)
8. [关键问题解决方案](#8-关键问题解决方案)
9. [项目文件结构](#9-项目文件结构)
10. [分阶段开发计划](#10-分阶段开发计划)
11. [Cursor 开发策略（防止上下文爆炸）](#11-cursor-开发策略防止上下文爆炸)
12. [成本估算](#12-成本估算)
13. [风险清单与应对](#13-风险清单与应对)
14. [需要用户协助的事项](#14-需要用户协助的事项)

---

## 1. 项目愿景

### 1.1 这是什么？

这不是一个简单的工具集合，而是一个**模拟真实游戏公司的 AI 社区平台**。

- 你打开浏览器，看到一个 2D 的"办公室"画面
- 里面有多个 AI 员工（策划、程序员、美术、测试等）在各自的工位上工作
- 它们会自由交流：程序员遇到策划文档不清楚的地方，会主动去找策划讨论
- 遇到重大问题或分歧时，会来找你（老板）做决定
- 你可以实时看到它们的对话、代码产出、美术素材
- 你发起一个项目（比如"做一个贪吃蛇游戏"），然后观察整个公司运转起来

### 1.2 用户的三个角色

| 角色 | 说明 |
|------|------|
| **观察者** | 通过 2D 可视化界面实时观看 Agent 们的工作状态和对话 |
| **决策者** | 在关键节点审批方案、解决分歧、确认方向 |
| **项目发起者** | 输入游戏创意，启动开发项目 |

### 1.3 第一版成功标准

> 你在浏览器中输入"做一个贪吃蛇游戏"，看着 AI 员工们讨论、写代码、画素材、测试，最终在 `output/` 文件夹中生成一个可用浏览器打开并游玩的贪吃蛇游戏。整个过程你能在 2D 界面上实时观察。

---

## 2. 系统架构总览

```
┌─────────────────────────────────────────────────────────────────┐
│                        浏览器（前端）                             │
│  ┌──────────────┐  ┌──────────────┐  ┌────────────────────┐    │
│  │ 2D 办公室视图 │  │ 对话日志面板  │  │ 老板决策面板       │    │
│  │ (Pixi.js)    │  │ (实时聊天流)  │  │ (审批/指令/反馈)   │    │
│  └──────────────┘  └──────────────┘  └────────────────────┘    │
│  ┌──────────────┐  ┌──────────────┐                            │
│  │ 项目状态面板  │  │ 文件浏览器   │                            │
│  │ (进度/阶段)   │  │ (代码/素材)  │                            │
│  └──────────────┘  └──────────────┘                            │
└──────────────────────────┬──────────────────────────────────────┘
                           │ WebSocket（实时双向通信）
                           │
┌──────────────────────────┴──────────────────────────────────────┐
│                     Python 后端服务                               │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    消息总线 (Message Bus)                 │    │
│  │  所有 Agent 的消息都经过这里 → 记录日志 → 推送给前端      │    │
│  └────────┬────────────┬────────────┬──────────┬───────────┘    │
│           │            │            │          │                 │
│  ┌────────┴──┐ ┌───────┴──┐ ┌──────┴───┐ ┌───┴────────┐       │
│  │ 策划Agent │ │程序员Agent│ │美术Agent  │ │ 测试Agent  │       │
│  │           │ │          │ │          │ │            │       │
│  │ LLM调用   │ │ LLM调用  │ │ LLM调用  │ │ LLM调用    │       │
│  │ +工具集   │ │ +工具集   │ │ +工具集  │ │ +工具集    │       │
│  └───────────┘ └──────────┘ └──────────┘ └────────────┘       │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    共享知识库                              │    │
│  │  项目规范 / 接口注册表 / 策划文档 / 代码文件 / 美术素材    │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │                    工具系统                                │    │
│  │  文件读写 / 代码执行 / AI绘图 / 浏览器截图 / 代码搜索     │    │
│  └─────────────────────────────────────────────────────────┘    │
└──────────────────────────────────────────────────────────────────┘
                           │
                           ▼
              ┌─────────────────────────┐
              │    外部 API 服务                │
              │  Google Gemini 3 Pro（主力）    │
              │  OpenAI DALL-E 3（美术素材）    │
              │  DeepSeek V3（备选/降本）       │
              └────────────────────────────────┘
```

---

## 3. 技术选型

### 3.1 后端

| 组件 | 技术 | 选择理由 |
|------|------|---------|
| 语言 | **Python 3.11+** | AI/ML 生态最丰富 |
| Web 框架 | **FastAPI** | 原生支持 WebSocket，异步性能好 |
| Agent 引擎 | **自研（基于 LLM API）** | 比 CrewAI 更灵活，可实现自由对话模式 |
| 消息总线 | **Python asyncio Queue** | 轻量，够用，无需外部依赖 |
| LLM 调用 | **Google Generative AI SDK / LiteLLM** | 主力使用 Gemini 3 Pro，LiteLLM 兼容多家模型切换 |
| 任务调度 | **asyncio** | Python 原生异步 |

> **为什么自研 Agent 引擎而不直接用 CrewAI？**
> 
> 因为需求是"自由交流的社区"，而 CrewAI 是"流水线式"的。CrewAI 中 Agent A 说完→Agent B 接着说，不能中途打断或自由发起对话。我们需要的是：任何 Agent 在任何时候都可以找任何其他 Agent 聊天，这需要自研一个基于消息总线的引擎。但设计会参考 CrewAI 的角色定义方式，保持简洁。

### 3.2 前端

| 组件 | 技术 | 选择理由 |
|------|------|---------|
| 框架 | **原生 HTML + CSS + JS**（第一版） | 简单直接，减少复杂度 |
| 2D 渲染 | **Canvas API / Pixi.js** | 用于渲染办公室场景和 Agent 角色 |
| 实时通信 | **WebSocket** | 双向实时推送 Agent 活动 |
| UI 组件 | **原生 DOM** | 对话面板、按钮等 |

### 3.3 AI 游戏产出技术栈

AI 公司"生产"的游戏使用的技术：

| 技术 | 说明 |
|------|------|
| **HTML5 + Canvas + JavaScript** | AI 代码生成质量最高，浏览器直接运行 |

### 3.4 外部 API

| 服务 | 用途 | 必须/可选 |
|------|------|----------|
| **Google Gemini 3 Pro** | Agent 的"大脑"，主力模型，100万上下文 + Deep Think + Agentic 优化 | **必须** |
| **OpenAI DALL-E 3** | 美术 Agent 生成游戏素材图片 | 可选（第一版可用色块代替） |
| **DeepSeek V3** | 备选大脑，国内直连，更便宜 | 可选（备用） |

> **为什么选择 Gemini 3 Pro 作为主力模型？**
> 
> 1. **100 万 token 上下文窗口**（GPT-4o 只有 128K）——程序员 Agent 可以一次"看到"整个项目所有代码和文档，极大缓解记忆混乱问题
> 2. **Deep Think 深度推理**——遇到复杂 Bug 时会自动深入思考，修 Bug 能力更强
> 3. **专为 Agent 任务优化**——Google 官方定位就是"最强自主 Agent 模型"，工具调用评测 85.4%
> 4. **多模态理解**——测试 Agent 可以"看"游戏截图来判断界面是否正确
> 5. **上下文缓存**——项目规范等重复读取的文件可缓存，费用降至原价 1/10
> 6. **Vibe Coding**——能根据自然语言描述直接生成完整应用代码

### 3.5 各 Agent 模型分配

| Agent | 模型 | 理由 |
|-------|------|------|
| 项目经理 | Gemini 3 Pro | 需要理解全局项目信息，大上下文有优势 |
| 游戏策划 | Gemini 3 Pro | Deep Think 帮助设计更严谨的玩法和数值 |
| 游戏程序员 | Gemini 3 Pro | 最关键角色：100万上下文能看完所有代码防止重复 + Deep Think 修 Bug |
| 美术设计师 | Gemini 3 Pro | 多模态理解美术需求，绘图部分另外调用 DALL-E 3 |
| 测试工程师 | Gemini 3 Pro | 多模态"看"游戏截图判断对错 + Deep Think 分析 Bug 根因 |

### 3.6 Gemini 3 Pro API 价格

| 项目 | 价格（每百万 token） |
|------|-------------------|
| 输入（≤200K token） | $2.00 |
| 输入（>200K token） | $4.00 |
| 输出（≤200K token） | $12.00 |
| 输出（>200K token） | $18.00 |
| **上下文缓存（重复内容）** | **$0.20-$0.40（大幅节省）** |
| 缓存存储 | $4.50/百万token/小时 |

---

## 4. Agent 角色设计

### 4.1 第一版角色（5 个）

#### 项目经理 (PM)

```yaml
名称: 项目经理
代号: pm
职责:
  - 接收老板（用户）的游戏需求
  - 将需求拆解为具体任务，分配给对应的员工
  - 监控项目进度，协调各角色之间的冲突
  - 当出现分歧或阻塞时，汇报给老板决策
触发沟通的场景:
  - 收到老板的新项目需求 → 组织全员会议
  - 某个 Agent 汇报进度或问题 → 判断是否需要协调
  - 项目阶段完成 → 汇报给老板并请求审批
工具: 无（纯沟通调度）
```

#### 游戏策划 (Planner)

```yaml
名称: 游戏策划
代号: planner
职责:
  - 根据 PM 的任务，撰写游戏策划文档 (GDD)
  - 定义游戏玩法、规则、关卡、数值配置表
  - 输出结构化的配置数据（YAML 格式）
  - 回答程序员和美术关于设计意图的疑问
触发沟通的场景:
  - 程序员问"这个功能具体要怎么表现" → 解释并补充文档
  - 美术问"角色应该长什么样" → 提供描述
  - 测试反馈"这个玩法不合理" → 和 PM 讨论是否调整
工具: 文件写入（输出策划文档和配置表）
```

#### 游戏程序员 (Programmer)

```yaml
名称: 游戏程序员
代号: programmer
职责:
  - 根据策划文档和技术设计编写游戏代码
  - 维护代码结构，确保模块化
  - 读取并遵守项目规范和接口注册表
  - 修复测试 Agent 反馈的 Bug
触发沟通的场景:
  - 策划文档有歧义 → 主动找策划确认
  - 发现策划需求技术上难以实现 → 找 PM 讨论替代方案
  - 需要美术素材才能继续 → 找美术确认进度
  - 测试反馈 Bug → 阅读 Bug 报告并修复
工具: 文件读写、代码执行、代码搜索
```

#### 美术设计师 (Artist)

```yaml
名称: 美术设计师
代号: artist
职责:
  - 根据策划文档中的美术需求生成游戏素材
  - 调用 AI 绘图工具生成图片
  - 确保所有素材符合项目规范中的尺寸和命名规则
  - 将素材存放到指定目录
触发沟通的场景:
  - 策划的描述不够具体 → 找策划确认
  - 生成的素材风格不确定 → 请老板审批
  - 程序员需要特定格式的素材 → 和程序员对齐规格
工具: AI 绘图 API、文件写入、图片处理
```

#### 测试工程师 (Tester)

```yaml
名称: 测试工程师
代号: tester
职责:
  - 运行游戏代码，检查是否能正常启动和运行
  - 根据策划文档验证功能是否正确实现
  - 撰写测试报告，列出 Bug 和问题
  - 将 Bug 反馈给程序员
触发沟通的场景:
  - 发现代码 Bug → 反馈给程序员，附上错误信息
  - 发现玩法和策划不一致 → 找策划确认是 Bug 还是设计变更
  - 严重问题多次修不好 → 上报 PM，PM 汇报老板
工具: 代码执行、浏览器截图（可选）
```

### 4.2 Agent 自由沟通机制

这是与传统"流水线"框架的最大区别。Agent 可以在任何时候发起对话：

```
消息格式：
{
    "from": "programmer",       // 发送者
    "to": "planner",            // 接收者（可以是 "all" 表示群发）
    "type": "question",         // 消息类型: question / answer / report / request_review
    "content": "策划文档里说食物有特殊效果，但没说效果持续多久，请补充",
    "context": "正在开发 food.js 模块",
    "priority": "normal",       // normal / urgent / blocking
    "timestamp": "2026-02-11T10:30:00Z"
}
```

**消息流转规则：**

1. 普通消息：直接发给目标 Agent，对方在当前任务的适当间隙处理
2. 紧急消息 (urgent)：中断目标 Agent 当前工作，优先处理
3. 阻塞消息 (blocking)：发送者暂停工作，等待回复后继续
4. 群发消息 (to: "all")：所有 Agent 都能看到，用于公告或全员讨论
5. 上报老板 (to: "boss")：触发前端弹窗，等待用户回复

---

## 5. 核心机制设计

### 5.1 消息总线 (Message Bus)

所有 Agent 之间的沟通都通过消息总线，它是整个系统的"神经中枢"：

```
Agent A 发消息 → 消息总线 → 记录到日志文件
                         → 推送给前端（实时显示）
                         → 转发给目标 Agent
                         → 如果是给老板的，触发前端弹窗等待回复
```

**消息总线的职责：**
- 路由消息到正确的接收者
- 记录所有消息到日志（可追溯）
- 通过 WebSocket 推送给前端（实时可视化）
- 管理消息队列（防止 Agent 被消息淹没）

### 5.2 Agent 工作循环

每个 Agent 不是"被动等待任务"，而是有自己的工作循环：

```python
# 伪代码：每个 Agent 的主循环
async def agent_work_loop(agent):
    while True:
        # 1. 检查是否有新消息需要处理
        message = await check_messages(agent.inbox)
        if message:
            response = await agent.think_and_respond(message)
            await message_bus.send(response)
            continue

        # 2. 检查是否有分配给自己的任务
        task = await check_tasks(agent.task_queue)
        if task:
            # 工作前：读取项目规范和相关文件
            context = await load_work_context(agent, task)
            # 执行工作（可能产生多轮 LLM 调用）
            result = await agent.work_on_task(task, context)
            # 工作后：更新文件、注册表等
            await save_work_result(result)
            # 汇报完成
            await message_bus.send(report_to_pm(result))
            continue

        # 3. 没有消息也没有任务，空闲等待
        await asyncio.sleep(2)
```

### 5.3 人类介入机制

当 Agent 需要老板决策时：

```
Agent 发送消息 (to: "boss", type: "request_review")
        │
        ▼
消息总线检测到目标是 boss
        │
        ▼
通过 WebSocket 推送到前端
        │
        ▼
前端弹出决策面板：
  ┌─────────────────────────────────────────┐
  │  策划需要你的确认                         │
  │                                         │
  │  "贪吃蛇游戏的难度设计有两个方案：        │
  │   A: 速度逐渐加快                        │
  │   B: 增加障碍物                          │
  │   请老板选择方向。"                       │
  │                                         │
  │  [选择A]  [选择B]  [都要]  [输入意见]     │
  └─────────────────────────────────────────┘
        │
    用户点击后
        │
        ▼
通过 WebSocket 发回后端 → 消息总线 → 转发给提问的 Agent
```

### 5.4 共享知识库（解决记忆问题的核心）

**原则：Agent 的 LLM 上下文不可信，文件才是唯一的事实来源。**

共享知识库是一组文件，所有 Agent 在工作前必须读取相关的文件：

```
shared_knowledge/
├── project_rules.yaml          # 项目总规范（命名、尺寸、技术栈等）
├── game_design_doc.md          # 游戏策划文档 (GDD)
├── tech_design_doc.md          # 技术设计文档 (TDD)
├── api_registry.yaml           # 接口注册表（所有已有函数）
├── config_tables.yaml          # 策划配置表（数值、关卡等）
├── art_asset_list.yaml         # 美术素材清单（已有/待生成）
├── bug_tracker.yaml            # Bug 列表
└── decision_log.yaml           # 老板的所有决策记录
```

**强制读取规则：**

| Agent | 工作前必须读取的文件 | 工作后必须更新的文件 |
|-------|-------------------|-------------------|
| PM | 所有文件 | decision_log |
| 策划 | project_rules, decision_log | game_design_doc, config_tables |
| 程序员 | project_rules, tech_design_doc, api_registry, config_tables | api_registry, 代码文件 |
| 美术 | project_rules, game_design_doc, art_asset_list | art_asset_list, 素材文件 |
| 测试 | game_design_doc, config_tables, api_registry | bug_tracker |

### 5.5 接口注册表（防止重复代码）

```yaml
# shared_knowledge/api_registry.yaml
# =============================================
# 接口注册表 - 所有已创建的函数/类/模块
# 程序员 Agent 写代码前【必须】查阅此表
# 写完代码后【必须】更新此表
# =============================================

last_updated: "2026-02-11T10:30:00Z"
updated_by: "programmer"

modules:
  "js/snake.js":
    description: "蛇对象及其行为逻辑"
    exports:
      - name: "class Snake"
        methods:
          - signature: "constructor(startX, startY, gridSize)"
            description: "创建蛇实例"
          - signature: "move(direction) → void"
            description: "向指定方向移动一格"
          - signature: "grow() → void"
            description: "蛇身增长一节"
          - signature: "getHeadPosition() → {x, y}"
            description: "返回蛇头坐标"
          - signature: "checkSelfCollision() → boolean"
            description: "检查是否咬到自己"

  "js/food.js":
    description: "食物生成和管理"
    exports:
      - name: "class FoodManager"
        methods:
          - signature: "spawnFood(type, excludePositions) → {x, y, type}"
            description: "在空位生成食物，excludePositions 是蛇身占据的格子"
          - signature: "checkEaten(headPos) → Food|null"
            description: "检查蛇头是否吃到食物"

  "js/config.js":
    description: "游戏配置数据（由策划配置表生成）"
    exports:
      - name: "GAME_CONFIG"
        type: "object"
        description: "全局配置对象，包含所有数值配置"
```

**程序员 Agent 的 Prompt 中硬编码的规则：**

```
## 铁律（不可违反）

1. 写任何代码之前，必须先用文件读取工具读取 api_registry.yaml
2. 如果需要的功能已在注册表中存在，直接 import 使用，禁止重写
3. 新建任何函数/类后，必须立即更新 api_registry.yaml
4. 所有数值配置必须从 config.js 读取，禁止在代码中硬编码数字
5. 文件命名、函数命名必须遵守 project_rules.yaml 中的命名规范
```

---

## 6. 前端可视化设计

### 6.1 界面布局

```
┌─────────────────────────────────────────────────────────────┐
│  AI 游戏开发公司                              [项目: 贪吃蛇]  │
├─────────────────────────────┬───────────────────────────────┤
│                             │  实时对话                      │
│                             │ ─────────────────────────────  │
│    2D 办公室视图             │ [策划→程序员] 配置表已更新，    │
│                             │  食物类型新增了"炸弹"，         │
│  ┌────┐      ┌────┐        │  请注意更新代码。               │
│  │策划│      │ PM │        │                                │
│  │💬  │      │🔍  │        │ [程序员→策划] 收到，但炸弹的    │
│  └────┘      └────┘        │  爆炸范围是几格？文档里没写。    │
│                             │                                │
│  ┌────┐      ┌────┐        │ [策划→程序员] 爆炸范围是周围     │
│  │程序│      │美术│        │  3x3 格子，我更新到配置表里了。  │
│  │⌨️  │      │🎨  │        │                                │
│  └────┘      └────┘        │ [测试→PM] 发现严重Bug：         │
│                             │  蛇穿过右边墙壁后不会死亡       │
│       ┌────┐               │                                │
│       │测试│               │ [PM→程序员] 测试发现碰撞Bug，   │
│       │🔧  │               │  请优先修复。                   │
│       └────┘               │                                │
│                             │                                │
├─────────────────────────────┼───────────────────────────────┤
│  项目状态                    │  文件浏览器                     │
│ ───────────────             │ ──────────────                 │
│ 阶段: 开发中 [████░░] 60%   │ output/snake_game/            │
│ 当前任务:                    │  ├── index.html               │
│  · 程序员: 修复碰撞Bug       │  ├── js/                      │
│  · 美术: 生成炸弹素材        │  │  ├── game.js               │
│  · 测试: 等待修复后复测       │  │  ├── snake.js              │
│ 已完成: 8/14 个任务          │  │  ├── food.js (编辑中)       │
│                             │  │  └── config.js              │
│                             │  └── assets/                   │
│                             │     ├── snake.png              │
│                             │     └── bomb.png (生成中)      │
├─────────────────────────────┴───────────────────────────────┤
│ 老板操作台                                                    │
│ [发起新项目]  [暂停项目]  [全员会议]  [查看决策历史]            │
│                                                              │
│ PM 请求你的决策：测试发现碰撞Bug反复修不好(已修3次)，          │
│ 是否需要人工介入？  [让它再试一次]  [我来看看代码]  [跳过此Bug] │
└──────────────────────────────────────────────────────────────┘
```

### 6.2 2D 办公室视觉元素

| 元素 | 说明 |
|------|------|
| Agent 头像 | 每个角色有一个像素风小人或图标 |
| 状态气泡 | 正在对话 / 正在写代码 / 正在画画 / 空闲 / 修Bug |
| 连线动画 | 两个 Agent 对话时，之间出现虚线连接 |
| 传递动画 | 文件交接时，有一个"文件图标"从 A 飞向 B |
| 进度条 | 每个 Agent 头上显示当前任务进度 |
| 警报动画 | 发现 Bug 或需要老板决策时，红色闪烁 |

### 6.3 前端与后端通信

通过 WebSocket 传输以下类型的实时事件：

```javascript
// 后端推送给前端的事件类型
{
    "event": "agent_message",      // Agent 发了一条消息
    "event": "agent_status",       // Agent 状态变化（空闲→工作中）
    "event": "file_update",        // 项目文件被创建或修改
    "event": "phase_change",       // 项目阶段变更
    "event": "boss_decision",      // 需要老板做决定
    "event": "task_complete",      // 某个任务完成
    "event": "error_alert"         // 出现严重错误
}
```

---

## 7. 游戏开发工作流

### 7.1 完整流程

```
用户输入: "做一个贪吃蛇游戏，像素风，带道具系统"
    │
    ▼
[阶段 1: 立项] ─── PM 接收需求
    │  PM 理解需求，组织"全员会议"，宣布项目启动
    │  PM 分配第一个任务给策划
    ▼
[阶段 2: 策划] ─── 策划编写 GDD
    │  策划输出: game_design_doc.md + config_tables.yaml
    │  PM 审核后提交给老板审批 ←── 【老板决策点 1】
    ▼
[阶段 3: 技术设计] ─── 程序员设计架构
    │  程序员输出: tech_design_doc.md + api_registry.yaml（初始版）
    │  确定文件结构和模块划分
    ▼
[阶段 4: 并行开发] ─── 程序员 + 美术 同时工作
    │  程序员: 按模块逐一编写代码
    │  美术: 按素材清单逐一生成图片
    │  两者通过消息总线沟通，遇到问题找策划
    │  美术素材完成后提交老板过目 ←── 【老板决策点 2】
    ▼
[阶段 5: 整合] ─── 程序员整合代码和素材
    │  将美术素材放入代码对应位置
    │  确保所有模块能协同工作
    ▼
[阶段 6: 测试] ─── 测试运行游戏
    │  测试输出: bug_tracker.yaml
    │  Bug 反馈给程序员修复
    │  修复后重新测试（最多循环 3 轮）
    │  3 轮修不好 → 上报老板 ←── 【老板决策点 3】
    ▼
[阶段 7: 交付] ─── PM 汇报项目完成
    │  输出完整的游戏文件夹
    │  PM 总结项目报告
    │  老板试玩 ←── 【老板决策点 4: 接受/要求修改】
    ▼
  完成
```

### 7.2 自由对话场景举例

以下是 Agent 之间可能发生的自由对话：

**场景：程序员发现策划漏洞**
```
程序员 → 策划: "你的配置表里 food_lightning 的 effect 写的是 speed_up，
                但是速度增加多少？加速后上限是多少？"
策划 → 程序员: "好问题，速度增加 50%，上限不超过 max_speed (15格/秒)。
                我已经更新了 config_tables.yaml。"
程序员 → 策划: "收到，已读取最新配置。"
```

**场景：测试发现问题后的连锁讨论**
```
测试 → PM: "严重Bug：蛇吃到加速道具后速度叠加没有上限，
            连吃3个就快到看不见了。"
PM → 程序员: "测试发现速度叠加Bug，请检查。"
程序员 → 策划: "我看了代码，速度叠加确实没做上限检查。
                但策划文档里也没提到叠加场景怎么处理？"
策划 → 程序员: "应该是：多个加速效果不叠加，只刷新持续时间。
                我更新到 GDD 里了。"
程序员 → 测试: "已修复，请复测。"
测试 → PM: "复测通过"
```

---

## 8. 关键问题解决方案

### 8.1 上下文爆炸 / 记忆混乱

| 策略 | 实现方式 |
|------|---------|
| **文件即真相** | 所有共识写入 YAML/MD 文件，Agent 工作前先读文件 |
| **精简上下文** | 每次 LLM 调用只注入当前任务所需的文件内容，不塞入全部历史 |
| **阶段性摘要** | 每个阶段结束生成摘要文件，下一阶段读摘要而非完整历史 |
| **上下文预算管理** | 代码中计算 token 数，超过阈值时自动裁剪旧内容（Gemini 3 Pro 100万上下文大幅缓解此问题） |
| **对话滑窗** | Agent 之间的对话历史只保留最近 50 条（得益于 Gemini 大上下文），更早的归档到文件 |
| **上下文缓存** | 利用 Gemini 3 Pro 的 Context Caching 功能，将项目规范等固定文档缓存，减少 90% 重复读取费用 |

### 8.2 规范统一

| 策略 | 实现方式 |
|------|---------|
| **project_rules.yaml** | 项目规范文件，所有 Agent 的 System Prompt 都要求先读这个文件 |
| **config_tables.yaml** | 策划输出的结构化配置，程序员直接解析生成 config.js |
| **架构师把关** | 技术设计阶段由程序员确定所有文件名和接口签名，策划和美术必须遵守 |
| **自动验证** | 代码写完后自动检查命名是否符合 project_rules 中的规范 |

### 8.3 防止重复代码

| 策略 | 实现方式 |
|------|---------|
| **api_registry.yaml** | 接口注册表，程序员写前必查，写后必更新 |
| **代码搜索工具** | 程序员 Agent 有一个工具可以搜索现有代码中的函数名 |
| **Prompt 硬约束** | 在程序员的 System Prompt 中写明"禁止重复实现已有接口" |
| **代码审查步骤** | 每次代码提交后，由另一个 LLM 调用快速审查是否有重复 |

### 8.4 死循环防护

| 策略 | 实现方式 |
|------|---------|
| **最大重试次数** | Bug 修复最多 3 轮，超过则上报老板 |
| **消息频率限制** | 同一对 Agent 之间 1 分钟内最多 10 条消息 |
| **总 Token 预算** | 单个项目设置 Token 上限，接近时警告老板 |
| **人类熔断** | 任何 Agent 可以发 escalate_to_boss 消息触发人工介入 |

---

## 9. 项目文件结构

```
d:\Cursor\AI公司\
│
├── 开发计划.md                         ← 本文件（总纲）
├── .env                                ← API Key 配置（不上传 Git）
├── requirements.txt                    ← Python 依赖
├── README.md                           ← 项目简介
│
├── .cursor/                            ← Cursor IDE 配置
│   └── rules/                          ← Cursor AI 规则文件
│       ├── global.mdc                  ← 全局开发规则
│       ├── backend.mdc                 ← 后端代码开发规则
│       ├── frontend.mdc                ← 前端代码开发规则
│       └── agent-engine.mdc            ← Agent 引擎开发规则
│
├── backend/                            ← Python 后端
│   ├── main.py                         ← 入口：启动 FastAPI 服务
│   ├── config.py                       ← 后端配置（模型选择、端口等）
│   │
│   ├── engine/                         ← Agent 引擎核心
│   │   ├── __init__.py
│   │   ├── agent.py                    ← Agent 基类（定义 Agent 的行为）
│   │   ├── message_bus.py              ← 消息总线
│   │   ├── task_manager.py             ← 任务管理器
│   │   ├── context_manager.py          ← 上下文管理（防止爆炸）
│   │   └── llm_client.py              ← LLM API 调用封装
│   │
│   ├── agents/                         ← 各个 Agent 的具体定义
│   │   ├── __init__.py
│   │   ├── pm_agent.py                 ← 项目经理
│   │   ├── planner_agent.py            ← 策划
│   │   ├── programmer_agent.py         ← 程序员
│   │   ├── artist_agent.py             ← 美术
│   │   └── tester_agent.py             ← 测试
│   │
│   ├── tools/                          ← Agent 使用的工具
│   │   ├── __init__.py
│   │   ├── file_tool.py                ← 文件读写
│   │   ├── code_runner.py              ← 代码执行（沙箱）
│   │   ├── image_gen_tool.py           ← AI 绘图
│   │   └── code_search_tool.py         ← 代码搜索
│   │
│   ├── workflows/                      ← 工作流定义
│   │   ├── __init__.py
│   │   └── game_dev_workflow.py        ← 游戏开发标准流程
│   │
│   └── api/                            ← Web API 和 WebSocket
│       ├── __init__.py
│       ├── websocket_handler.py        ← WebSocket 处理
│       └── http_routes.py              ← HTTP 接口（启动项目、老板操作等）
│
├── frontend/                           ← 前端（浏览器界面）
│   ├── index.html                      ← 主页面
│   ├── css/
│   │   └── style.css                   ← 样式
│   ├── js/
│   │   ├── app.js                      ← 前端入口
│   │   ├── websocket.js                ← WebSocket 连接管理
│   │   ├── office_view.js              ← 2D 办公室渲染
│   │   ├── chat_panel.js               ← 对话面板
│   │   ├── status_panel.js             ← 项目状态面板
│   │   ├── file_browser.js             ← 文件浏览器
│   │   └── boss_panel.js               ← 老板决策面板
│   └── assets/                         ← 前端素材（Agent 头像等）
│       ├── pm.png
│       ├── planner.png
│       ├── programmer.png
│       ├── artist.png
│       └── tester.png
│
├── projects/                           ← AI 开发的游戏项目存放处
│   └── {project_name}/                 ← 每个游戏一个文件夹
│       ├── shared_knowledge/           ← 该项目的共享知识库
│       │   ├── project_rules.yaml
│       │   ├── game_design_doc.md
│       │   ├── tech_design_doc.md
│       │   ├── api_registry.yaml
│       │   ├── config_tables.yaml
│       │   ├── art_asset_list.yaml
│       │   ├── bug_tracker.yaml
│       │   └── decision_log.yaml
│       ├── output/                     ← 游戏产出文件
│       │   ├── index.html
│       │   ├── js/
│       │   └── assets/
│       └── logs/                       ← 该项目的 Agent 对话日志
│           └── conversation.log
│
└── docs/                               ← 开发文档
    ├── agent_prompts.md                ← 所有 Agent 的 System Prompt 备份
    └── architecture.md                 ← 架构说明
```

---

## 10. 分阶段开发计划

### 总览

| 阶段 | 内容 | 预计工作量（Cursor 对话轮数） | 里程碑 |
|------|------|----------------------------|--------|
| **P0** | 环境搭建 | 1-2 轮 | Python 环境就绪，依赖安装完成 |
| **P1** | Agent 引擎核心 | 8-12 轮 | 一个 Agent 能接收指令并调用 LLM 回复 |
| **P2** | 消息总线 + 多 Agent | 6-10 轮 | 多个 Agent 能互相发消息并响应 |
| **P3** | 工具系统 | 6-8 轮 | Agent 能读写文件、执行代码 |
| **P4** | 游戏开发工作流 | 8-12 轮 | 输入需求后能跑通完整开发流程 |
| **P5** | Web 后端 API | 4-6 轮 | FastAPI + WebSocket 服务启动 |
| **P6** | 前端可视化 | 10-15 轮 | 浏览器中看到 2D 办公室和对话流 |
| **P7** | 人类介入机制 | 4-6 轮 | 老板能在前端审批和决策 |
| **P8** | 联调测试 | 5-8 轮 | 端到端跑通：输入需求 → 观看开发 → 获得游戏 |
| **P9** | 美术集成 | 3-5 轮 | 接入 DALL-E 生成游戏素材 |
| **P10** | 优化完善 | 5-8 轮 | Bug 修复、体验优化、成本优化 |

**总计预估：约 55-90 轮 Cursor Agent 对话**

---

### P0：环境搭建（第一步）

**目标**：确保开发环境就绪

**推荐使用的 Skills**:
- ✅ `python-design-patterns` - Python 项目结构设计
- ✅ `logging-best-practices` - 日志系统规划

**具体任务：**
1. 检查 Python 是否已安装（需要 3.11+）
2. 创建项目文件夹结构
3. 创建 `requirements.txt`，安装依赖
4. 创建 `.env` 文件模板
5. 创建 `.cursor/rules/` 规则文件

**需要用户做的事：**
- 确认 Python 是否已安装
- 提供 Google Gemini API Key（主力模型）
- （可选）提供 OpenAI API Key（用于 DALL-E 美术素材生成）

**依赖清单（初步）：**
```
fastapi>=0.110.0
uvicorn>=0.27.0
websockets>=12.0
google-generativeai>=0.8.0
openai>=1.12.0
litellm>=1.30.0
pydantic>=2.6.0
python-dotenv>=1.0.0
aiofiles>=23.2.0
pyyaml>=6.0.1
httpx>=0.27.0
Pillow>=10.2.0
```

---

### P1：Agent 引擎核心

**目标**：实现单个 Agent 的基本能力

**推荐使用的 Skills**:
- ✅ `python-design-patterns` - Agent 基类设计模式
- ✅ `async-python-patterns` - 异步 LLM 调用
- ✅ `llm-evaluation` - LLM 性能评估和优化
- ✅ `logging-best-practices` - 统一日志系统
- ✅ `python-testing-patterns` - 单元测试编写

**具体任务：**
1. `engine/llm_client.py` — 封装 LLM API 调用，主力 Gemini 3 Pro，兼容 OpenAI/DeepSeek
   - **改进**：添加指数退避重试机制（最多3次，延迟2/4/8秒）
   - **改进**：集成日志系统替代print输出
2. `engine/agent.py` — Agent 基类：
   - 有名字、角色、System Prompt
   - 能接收消息，调用 LLM 生成回复
   - 能使用工具
   - **改进**：集成日志系统
3. `engine/context_manager.py` — 上下文管理器：
   - 跟踪 token 使用量
   - 当上下文接近限制时自动裁剪旧消息
   - 注入必读文件内容
   - **改进**：集成日志系统

**验证标准**：在终端中运行脚本，一个 Agent 能回答你的问题。

**质量改进（基于P1测试反馈）：**
- ✅ 添加统一日志系统（`utils/logger.py`）
- ✅ LLM调用添加重试机制（`utils/retry.py`）
- ⏸️ 迁移到google.genai包（延后到P10）

---

### P2：消息总线 + 多 Agent 协作

**目标**：多个 Agent 能互相对话

**推荐使用的 Skills**:
- ✅ `async-python-patterns` - 异步消息处理和事件循环
- ✅ `python-design-patterns` - 消息总线架构模式（观察者、发布订阅）
- ✅ `message-queues` - 消息队列设计和实现
- ✅ `logging-best-practices` - 消息日志记录
- ✅ `python-testing-patterns` - 消息路由测试

**具体任务：**
1. **前置任务（优先）：创建工具模块**
   - `utils/logger.py` — 统一日志系统
   - `utils/retry.py` — 重试机制装饰器
   - 更新已有模块（llm_client.py等）集成日志和重试
2. `engine/message_bus.py` — 消息总线：
   - 消息路由（点对点、广播）
   - 消息日志记录（使用统一日志系统）
   - 消息队列管理
3. 创建 5 个 Agent 定义文件（PM、策划、程序员、美术、测试）
4. 实现 Agent 工作循环（检查消息 → 处理 → 回复）
5. 实现 Agent 互相提问/回答的能力

**验证标准**：启动后，PM 能给策划发消息，策划能回复，程序员能找策划提问。

---

### P3：工具系统

**目标**：Agent 能操作真实文件

**推荐使用的 Skills**:
- ✅ `python-design-patterns` - 工具注册机制（工厂模式、策略模式）
- ✅ `async-python-patterns` - 异步文件操作
- ✅ `python-testing-patterns` - 工具功能测试
- ✅ `logging-best-practices` - 工具执行日志

**具体任务：**
1. `tools/file_tool.py` — 文件读写工具
2. `tools/code_runner.py` — 代码执行工具（在子进程中安全执行 JS/HTML）
3. `tools/code_search_tool.py` — 搜索现有代码中的函数名
4. 实现工具注册机制（Agent 声明自己有哪些工具）

**验证标准**：程序员 Agent 能创建一个 JS 文件并执行它。

---

### P4：游戏开发工作流

**目标**：跑通一次完整的游戏开发

**推荐使用的 Skills**:
- ✅ `python-design-patterns` - 工作流状态机设计
- ✅ `async-python-patterns` - 异步任务调度和编排
- ✅ `python-testing-patterns` - 工作流集成测试
- ✅ `logging-best-practices` - 工作流日志追踪

**具体任务：**
1. `workflows/game_dev_workflow.py` — 定义完整的阶段流程
2. 实现共享知识库的创建和管理
3. 实现 project_rules.yaml 自动生成
4. 实现 api_registry.yaml 自动维护
5. 实现"测试→修Bug→重测"循环
6. 实现阶段间的文档传递

**验证标准**：在终端中运行，输入"贪吃蛇游戏"，最终在 output/ 中生成可运行的游戏。

---

### P5：Web 后端 API ✅

**目标**：将后端暴露为 Web 服务
**状态**：✅ 已完成（2026-02-11）
**测试结果**：12/12 通过（100%）

**推荐使用的 Skills**:
- ✅ `fastapi-templates` - FastAPI 应用架构和最佳实践
- ✅ `api-design-principles` - RESTful API 设计规范
- ✅ `websocket-engineer` - WebSocket 服务端实现
- ✅ `async-python-patterns` - 异步请求处理
- ✅ `logging-best-practices` - API 请求日志
- ✅ `python-testing-patterns` - API 端点测试

**具体任务：**
1. `main.py` — FastAPI 应用配置
2. `api/http_routes.py` — HTTP 接口：
   - POST /project/start — 发起新项目
   - GET /project/status — 获取项目状态
   - POST /boss/decision — 老板提交决策
3. `api/websocket_handler.py` — WebSocket：
   - 实时推送 Agent 消息
   - 实时推送文件变更
   - 实时推送状态更新

**验证标准**：浏览器能通过 WebSocket 接收到 Agent 的对话消息。

---

### P6：前端可视化

**目标**：在浏览器中看到 AI 公司运行

**推荐使用的 Skills**:
- ✅ `modern-javascript-patterns` - 模块化 JavaScript 架构
- ✅ `websocket-engineer` - WebSocket 客户端实现
- ✅ `web-design-guidelines` - UI/UX 最佳实践审查
- ✅ `javascript-testing-patterns` - 前端功能测试

**具体任务：**
1. `frontend/index.html` — 主页面框架
2. `frontend/js/office_view.js` — 2D 办公室场景绘制
3. `frontend/js/chat_panel.js` — 实时对话面板
4. `frontend/js/status_panel.js` — 项目状态显示
5. `frontend/js/websocket.js` — 与后端实时通信
6. `frontend/css/style.css` — 界面样式
7. Agent 头像素材（可用简单图标代替）

**验证标准**：浏览器打开后，能看到 Agent 在办公室中的活动和对话。

---

### P7：人类介入机制

**目标**：老板能在关键节点做决策

**推荐使用的 Skills**:
- ✅ `websocket-engineer` - 双向实时消息传递
- ✅ `modern-javascript-patterns` - 交互逻辑实现
- ✅ `web-design-guidelines` - 决策面板 UX 优化
- ✅ `async-python-patterns` - 异步等待用户响应

**具体任务：**
1. `frontend/js/boss_panel.js` — 决策面板 UI
2. 后端实现"暂停等待老板"逻辑
3. 前端弹出决策窗口，支持选择/输入
4. 决策结果回传给 Agent

**验证标准**：策划完成后弹出审批窗口，老板点击确认后继续。

---

### P8：联调测试

**目标**：端到端完整流程跑通

**推荐使用的 Skills**:
- ✅ `python-testing-patterns` - 集成测试和 E2E 测试
- ✅ `javascript-testing-patterns` - 前端功能测试
- ✅ `llm-evaluation` - LLM 输出质量评估
- ✅ `logging-best-practices` - 测试日志分析
- ✅ `async-python-patterns` - 异步测试模式

**具体任务：**
1. 发起"贪吃蛇游戏"项目，全流程跑通
2. 修复联调过程中发现的 Bug
3. 优化 Agent Prompt（减少无效对话）
4. 调整上下文管理策略

**验证标准**：完整、流畅地跑完一个游戏开发项目。

---

### P9：美术集成

**目标**：AI 能生成实际的游戏素材

**推荐使用的 Skills**:
- ✅ `python-design-patterns` - 图片生成工具封装
- ✅ `async-python-patterns` - 异步 API 调用
- ✅ `logging-best-practices` - 图片生成日志
- ✅ `python-testing-patterns` - 图片生成测试

**具体任务：**
1. `tools/image_gen_tool.py` — 集成 DALL-E 3 API（美术素材生成，由 Gemini Agent 生成精确 Prompt 后调用）
2. 美术 Agent Prompt 优化（输出精确的绘图 Prompt）
3. 图片后处理（裁剪、缩放、格式转换）

**验证标准**：生成的游戏包含 AI 画的素材图片，而不是色块。

---

### P10：优化完善

**目标**：提升稳定性和体验

**推荐使用的 Skills**:
- ✅ `python-design-patterns` - 代码重构和优化
- ✅ `llm-evaluation` - LLM 性能优化和成本分析
- ✅ `web-design-guidelines` - UI 最终审查和优化
- ✅ `logging-best-practices` - 性能监控和日志分析
- ✅ `python-testing-patterns` - 回归测试
- ✅ `javascript-testing-patterns` - 前端性能测试

**具体任务：**
1. 错误处理和异常恢复
2. Token 成本优化（缓存、精简 Prompt）
3. 前端 UI 美化
4. 支持多种游戏类型的模板
5. 添加项目历史记录
6. **API迁移**：将 `google-generativeai` 迁移到 `google.genai` 新包
   - 更新 requirements.txt
   - 修改 llm_client.py 的 import 语句
   - 测试验证所有功能正常
7. **性能监控**：添加性能监控指标（可选）
   - LLM调用耗时统计
   - Token使用量监控
   - 生成性能报告

---

## 11. Cursor 开发策略（防止上下文爆炸）

> **重要**：这个项目本身的代码量不小（预计 3000-5000 行）。在 Cursor 中开发时，同样会遇到上下文爆炸的问题。以下是解决策略。

### 11.1 模块化开发原则

**每个文件保持在 150 行以内。** 如果超过，就拆分。

```
错误：把所有 Agent 逻辑写在一个 agent.py 里（500行）
正确：agent.py（基类100行）+ pm_agent.py（80行）+ planner_agent.py（80行）...
```

### 11.2 .cursor/rules 规则文件

在项目中创建 Cursor 规则文件，帮助 Cursor AI 理解项目结构，避免写出不一致的代码。

**global.mdc（全局规则）：**
```
# 项目全局规则

## 项目简介
这是一个 AI 多智能体协作平台，模拟游戏开发公司。

## 代码风格
- Python 代码使用 snake_case 命名
- 每个文件不超过 150 行
- 每个函数必须有 docstring
- 使用 type hints

## 架构
- backend/ 是 Python 后端，使用 FastAPI
- frontend/ 是纯 HTML+CSS+JS 前端
- engine/ 是 Agent 引擎核心
- 详细架构见 开发计划.md
```

**agent-engine.mdc（引擎开发规则）：**
```
# Agent 引擎开发规则

## 文件职责
- agent.py: Agent 基类，不要在这里写具体角色逻辑
- message_bus.py: 只负责消息路由和记录
- context_manager.py: 管理 LLM 上下文窗口大小
- llm_client.py: 只负责 API 调用，不包含业务逻辑

## 消息格式
所有 Agent 间消息必须使用以下格式：
{ from, to, type, content, context, priority, timestamp }

## 新增 Agent
添加新 Agent 时，在 agents/ 目录下创建新文件，继承 Agent 基类
```

### 11.3 分步开发、分步测试

**每完成一个模块就测试，不要等全部写完。**

| 开发完成 | 立即测试 |
|---------|---------|
| llm_client.py | 运行脚本测试能否调用 API |
| agent.py | 创建一个 Agent 对话测试 |
| message_bus.py | 测试两个 Agent 互发消息 |
| file_tool.py | 测试读写文件 |
| ... | ... |

### 11.4 阶段完成自测机制 (重要)

> **强制要求**: 每个P阶段完成后，AI必须自行进行完整测试，直到没有Bug才能进入下一阶段。

#### 自测流程

**每个P阶段开发完成后，必须执行以下步骤:**

```
1. 编写测试代码
   ├─ 为本阶段的核心功能编写测试脚本
   ├─ 测试所有关键方法和接口
   └─ 覆盖正常流程和异常情况

2. 运行测试
   ├─ 执行所有测试脚本
   ├─ 记录所有错误和异常
   └─ 截图或复制完整的错误信息

3. 修复Bug
   ├─ 分析错误原因
   ├─ 修改代码
   └─ 重新运行测试

4. 循环直到通过
   ├─ 重复步骤2-3直到所有测试通过
   ├─ 确保没有任何报错
   └─ 验证功能符合预期

5. 更新文档
   ├─ 更新 platform_constitution.md (记录已实现的内容)
   ├─ 记录本阶段遇到的关键问题和解决方案
   └─ 标记本阶段为 ✅ 已完成

6. 汇报用户
   ├─ 总结本阶段完成的功能
   ├─ 说明测试通过情况
   └─ 请求用户确认后才能进入下一阶段
```

#### 各阶段的测试标准

| 阶段 | 测试内容 | 通过标准 |
|------|---------|---------|
| **P0** | 环境验证 | 所有依赖安装成功，Python能正常运行，API Key配置正确 |
| **P1** | Agent引擎 | 能创建Agent实例，调用LLM返回正常，上下文管理正常工作 |
| **P2** | 消息通信 | 两个Agent能互发消息，消息被正确记录，路由规则正确 |
| **P3** | 工具调用 | 文件读写成功，代码能安全执行，搜索功能正常 |
| **P4** | 工作流 | 能完整跑通7个阶段，文档正确传递，知识库正确维护 |
| **P5** | Web服务 | FastAPI启动成功，HTTP接口返回正确，WebSocket能推送消息 |
| **P6** | 前端界面 | 页面正常显示，WebSocket连接成功，Agent状态正确渲染 |
| **P7** | 人类介入 | 决策请求能触发弹窗，用户回复能正确传回后端 |
| **P8** | 端到端 | 完整开发一个游戏项目，生成的游戏能在浏览器运行 |
| **P9** | 美术生成 | DALL-E调用成功，图片保存正确，素材符合规范 |
| **P10** | 优化 | 性能提升可量化，成本降低可验证，无明显Bug |

#### 测试代码示例

**P1阶段测试脚本示例:**
```python
# test_p1_agent_engine.py
import asyncio
from backend.engine.llm_client import LLMClient
from backend.engine.agent import Agent

async def test_llm_client():
    """测试LLM客户端能否正常调用API"""
    print("测试LLM客户端...")
    client = LLMClient()
    response = await client.generate([
        {"role": "user", "content": "你好，请回复'测试成功'"}
    ])
    assert "测试" in response or "成功" in response
    print("✅ LLM客户端测试通过")

async def test_agent_basic():
    """测试Agent基本功能"""
    print("测试Agent基类...")
    agent = Agent(
        agent_id="test_agent",
        role="测试员",
        system_prompt="你是一个测试Agent"
    )
    # 测试消息处理
    message = {
        "from": "user",
        "to": "test_agent",
        "type": "question",
        "content": "测试消息"
    }
    response = await agent.think_and_respond(message)
    assert response is not None
    print("✅ Agent基本功能测试通过")

async def main():
    try:
        await test_llm_client()
        await test_agent_basic()
        print("\n🎉 P1阶段所有测试通过！")
    except Exception as e:
        print(f"\n❌ 测试失败: {e}")
        raise

if __name__ == "__main__":
    asyncio.run(main())
```

#### 不允许跳过测试

**严格规则:**
- ❌ 禁止开发完就直接进入下一阶段
- ❌ 禁止说"应该没问题，可以继续了"
- ❌ 禁止测试失败就放弃修复
- ✅ 必须编写测试脚本并运行
- ✅ 必须修复所有发现的Bug
- ✅ 必须看到绿色的"✅ 测试通过"才能继续

**如果遇到难以修复的Bug:**
1. 尝试至少3种不同的修复方案
2. 如果仍然失败，详细记录问题并询问用户
3. 讨论是否需要调整设计或降低复杂度
4. 获得用户同意后才能调整方案或跳过

### 11.5 Cursor 对话管理

**每个开发阶段（P0-P10）开启一个新的 Cursor 对话。**

```
错误：从头到尾用一个对话完成所有开发（上下文必然爆炸）
正确：每个阶段一个新对话，开头先说"请阅读 开发计划.md 的 P3 部分"
```

**每次新对话的标准开场白：**
```
请先阅读以下文件:
1. 开发计划.md 中的 [P?] 阶段内容
2. platform_constitution.md (了解已完成的架构)
3. 当前已完成的代码文件: [列出相关文件]

然后开始实现 [P?] 阶段的任务。

重要提醒: 本阶段完成后必须进行完整自测(见11.4节)，
测试通过后才能更新宪法文档并进入下一阶段。
```

### 11.6 每个文件头部注释

每个代码文件的头部都要写一段注释，说明这个文件是做什么的。这样当 Cursor AI 读取这个文件时，能快速理解上下文：

```python
"""
文件: engine/message_bus.py
职责: Agent 间消息路由、记录和推送
依赖: engine/agent.py
被依赖: api/websocket_handler.py, agents/*.py
关键接口:
  - MessageBus.send(message) -> 发送消息
  - MessageBus.subscribe(agent_id, callback) -> 订阅消息
  - MessageBus.get_history(limit) -> 获取历史消息
"""
```

---

## 12. 成本估算

### 12.1 Cursor 订阅费用

| 项目 | 费用 | 说明 |
|------|------|------|
| Cursor Pro 订阅 | **$20/月** | 包含 500 次快速高级请求/月 |
| 预计开发消耗 | 55-90 轮对话 | 每轮可能 1-5 次请求 |
| 预计总请求数 | 150-400 次 | 一个月内大概率够用 |

**结论：$20/月的 Cursor 订阅够用，但建议：**
- 不要浪费请求在无关的事情上
- 如果一个月内没开发完，第二个月继续（$20/月自动续费）
- 当月请求快用完时，可以切换到慢速模式（不限量）

### 12.2 外部 API 费用（运行 AI 公司时的消耗）

这是 AI 公司运行时消耗的费用，**与 Cursor 订阅无关**，需要单独付费。

| 模型 | 用途 | 单个游戏项目预估消耗 | 费用 |
|------|------|-------------------|------|
| **Gemini 3 Pro** | Agent 的大脑（主力） | ~50万 token | **~$1.5-4** |
| Gemini 3 Pro（启用缓存后） | 同上，缓存项目规范等固定内容 | ~50万 token | **~$1-3（节省约30%）** |
| DALL-E 3 | 美术素材生成 | ~10-20张图 | **~$0.4-0.8** |
| DeepSeek V3（备选方案） | Agent 大脑（更便宜，国内直连） | ~50万 token | **~¥0.5-1** |

**单个简单游戏项目的总 API 费用：约 $2-5（启用缓存后可降至 $1.5-4）**

### 12.3 总成本预估

| 项目 | 费用 |
|------|------|
| Cursor 订阅（开发期） | $20-40（1-2个月） |
| Google Gemini API 充值（开发调试） | $10-15（调试多个游戏项目） |
| OpenAI API 充值（DALL-E 美术） | $5-10（可选，第一版可不用） |
| Gemini API（后续每个项目） | 每个游戏项目 $2-5 |
| **首次总投入** | **约 $30-55（约 ¥200-400）** |

---

## 13. 风险清单与应对

### 高风险

| 风险 | 影响 | 应对措施 |
|------|------|---------|
| **Agent 生成的代码有 Bug 且自己修不好** | 游戏无法运行 | 设置 3 轮重试上限 → 上报老板 → 老板可要求简化功能或跳过 |
| **上下文溢出导致 Agent 遗忘关键信息** | 代码和策划不一致 | 严格的"先读文件再工作"机制 + 接口注册表 |
| **Cursor 开发过程中对话过长导致 AI 质量下降** | 代码质量差 | 分阶段开发，每个阶段新开对话 |

### 中风险

| 风险 | 影响 | 应对措施 |
|------|------|---------|
| **API 费用超预期** | 花费过高 | 设置 Token 预算上限 + 启用 Gemini 上下文缓存 + 可切换 DeepSeek 降本 |
| **AI 生成的美术素材风格不统一** | 游戏视觉效果差 | 在 Prompt 中严格约束风格关键词 + 老板审批 |
| **Agent 之间的对话陷入无意义循环** | 浪费 Token，不产出 | 消息频率限制 + 超时自动跳过 |
| **前端 2D 可视化实现复杂度超预期** | 开发时间延长 | 第一版用极简风格（色块+文字），不追求精致 |

### 低风险

| 风险 | 影响 | 应对措施 |
|------|------|---------|
| **Python 环境安装失败** | 无法开始开发 | Cursor AI 可以帮助排查安装问题 |
| **Gemini / OpenAI API 网络问题** | 调用失败 | 增加重试机制 + 可切换备用模型（DeepSeek 国内直连） |

---

## 14. 需要用户协助的事项

### 开发开始前

| 序号 | 事项 | 说明 | 难度 |
|------|------|------|------|
| 1 | **确认 Python 是否已安装** | 在终端输入 `python --version`，需要 3.11 以上 | 简单 |
| 2 | **获取 Google Gemini API Key** | 去 ai.google.dev 注册并获取 API Key，充值 $10-15 | 中等 |
| 3 | **（可选）获取 OpenAI API Key** | 去 platform.openai.com 注册，用于 DALL-E 美术生成，充值 $5-10 | 中等 |
| 4 | **将 API Key 告知 Cursor** | Cursor 会帮你写入 .env 文件 | 简单 |

### 开发过程中

| 序号 | 事项 | 说明 | 频率 |
|------|------|------|------|
| 1 | **每个阶段结束后确认** | Cursor 完成一个阶段后，你确认"没问题，继续下一阶段" | 每阶段 1 次 |
| 2 | **运行测试命令** | Cursor 会告诉你运行什么命令（如 `python test_xxx.py`），你点击运行 | 偶尔 |
| 3 | **查看报错信息** | 如果运行出错，将错误信息复制给 Cursor 看 | 偶尔 |

### AI 公司运行时

| 序号 | 事项 | 说明 | 频率 |
|------|------|------|------|
| 1 | **在浏览器中打开界面** | Cursor 会给你一个网址（如 http://localhost:8000） | 每次启动 1 次 |
| 2 | **输入游戏创意** | 在界面中输入你想做的游戏 | 每个项目 1 次 |
| 3 | **审批决策** | 在界面中的弹窗中做选择 | 每个项目 3-5 次 |
| 4 | **试玩成品** | 在浏览器中打开生成的游戏 | 每个项目完成时 |

**你不需要做的事：**
- 不需要写任何代码
- 不需要理解代码
- 不需要手动安装库
- 不需要配置服务器

---

## 15. 测试反馈与改进措施

> **基于 P0-P1 阶段测试总结的改进计划**  
> **测试日期**: 2026-02-11  
> **测试状态**: ✅ 全部通过（26项测试全部通过）

### 15.1 发现的问题及解决方案

#### 问题 1: google.generativeai 包弃用警告

**严重程度**: 🟡 中等  
**当前影响**: 无（功能正常）  
**优先级**: 低

**解决方案**:
- **实施阶段**: P10 优化完善
- **具体措施**:
  1. 卸载旧包：`pip uninstall google-generativeai`
  2. 安装新包：`pip install google-genai`
  3. 修改 `llm_client.py`：将 `import google.generativeai` 改为 `import google.genai`
  4. 更新 `requirements.txt`
  5. 运行完整测试验证兼容性

**工作量估算**: 2-3小时

---

#### 问题 2: 缺少日志系统

**严重程度**: 🟡 中等  
**当前问题**: 使用 print 输出，不便于生产环境管理  
**优先级**: 中

**解决方案**:
- **实施阶段**: P2 阶段开始时（优先任务）
- **具体措施**:
  1. 创建 `backend/utils/logger.py` 统一日志模块
  2. 支持控制台输出和文件输出
  3. 支持日志级别：DEBUG/INFO/WARNING/ERROR
  4. 逐步替换所有模块的 print 为 logger
  5. 在 `.env` 中添加日志配置

**实施顺序**:
```
P2开始前：
1. 创建 utils/logger.py
2. 更新 llm_client.py（优先，调用最频繁）
3. 更新 context_manager.py
4. 更新 agent.py

P2-P3过程：
5. 其他新模块直接使用 logger
```

**日志配置示例**:
```python
# .env 配置
LOG_LEVEL=INFO        # DEBUG/INFO/WARNING/ERROR
LOG_TO_FILE=true      # 是否输出到文件

# 使用方式
from utils.logger import setup_logger
logger = setup_logger("module_name", log_level=Config.LOG_LEVEL)
logger.info("操作成功")
logger.error("操作失败", exc_info=True)
```

**工作量估算**: 2-3小时

---

#### 问题 3: LLM 调用无重试机制

**严重程度**: 🟡 中等  
**当前问题**: 网络抖动或 API 临时故障导致调用失败  
**优先级**: 中

**解决方案**:
- **实施阶段**: P2 阶段开始时（优先任务）
- **具体措施**:
  1. 创建 `backend/utils/retry.py` 重试装饰器
  2. 实现指数退避策略（2秒 → 4秒 → 8秒）
  3. 在 `llm_client.py` 的 `generate_response` 方法上应用装饰器
  4. 在 `.env` 和 `config.py` 中添加可配置参数

**重试策略**:
```python
# 配置
LLM_MAX_RETRIES=3           # 最大重试3次
LLM_RETRY_BASE_DELAY=2.0    # 基础延迟2秒
LLM_RETRY_MAX_DELAY=30.0    # 最大延迟30秒

# 效果
第1次失败 → 等待2秒后重试
第2次失败 → 等待4秒后重试
第3次失败 → 抛出异常
```

**预期效果**:
- 网络抖动：自动恢复，成功率提升
- API限流：等待后重试
- 真正的错误：3次后抛出异常
- 用户体验：更稳定

**工作量估算**: 1-2小时

---

### 15.2 改进措施优先级

| 优先级 | 改进项 | 实施阶段 | 工作量 | 状态 |
|--------|--------|---------|--------|------|
| 🔴 高 | 添加日志系统 | P2开始前 | 2-3h | ⏸️ 待实施 |
| 🔴 高 | 添加重试机制 | P2开始前 | 1-2h | ⏸️ 待实施 |
| 🟡 中 | 引入pytest测试框架 | P8联调前 | 3-4h | ⏸️ 待实施 |
| 🟢 低 | 添加性能监控 | P10 | 2-3h | ⏸️ 待实施 |
| 🟢 低 | 迁移到google.genai | P10 | 2-3h | ⏸️ 待实施 |

### 15.3 P2 阶段前置任务清单

在开始 P2 消息总线开发前，**必须先完成**以下改进：

- [ ] 创建 `backend/utils/` 目录
- [ ] 创建 `backend/utils/__init__.py`
- [ ] 实现 `backend/utils/logger.py` （统一日志系统）
- [ ] 实现 `backend/utils/retry.py` （重试装饰器）
- [ ] 更新 `backend/engine/llm_client.py` 集成日志和重试
- [ ] 更新 `backend/engine/context_manager.py` 集成日志
- [ ] 更新 `backend/engine/agent.py` 集成日志
- [ ] 更新 `.env` 添加日志和重试配置
- [ ] 更新 `backend/config.py` 添加配置项
- [ ] 运行测试验证改进效果

**预计总工作量**: 3-5小时  
**建议**: 在 P2 主要功能开发前完成，避免后续大量修改

### 15.4 额外建议（可选）

以下是基于测试经验的额外改进建议：

1. **配置验证增强**
   - 检查 API Key 格式
   - 检查模型名称有效性
   - 检查数值配置合理性

2. **性能监控埋点**（P10实施）
   ```python
   import time
   start = time.time()
   # LLM调用
   logger.info(f"LLM调用耗时: {time.time()-start:.2f}秒")
   ```

3. **单元测试框架**（P8实施）
   - 使用 pytest
   - 为每个核心函数编写测试
   - 提高代码质量

---

## 附录 A：术语对照表

| 术语 | 说明 |
|------|------|
| Agent | AI 智能体，相当于一个 AI 员工 |
| LLM | 大语言模型（如 Gemini 3 Pro），Agent 的"大脑" |
| Token | LLM 处理的最小文本单位，约 3/4 个英文单词或半个汉字 |
| API Key | 调用 AI 服务的密钥，类似于密码 |
| WebSocket | 一种网络协议，支持浏览器和服务器实时双向通信 |
| FastAPI | 一个 Python Web 框架，用于构建后端服务 |
| 上下文窗口 | LLM 一次能"看到"的最大文本量 |
| RAG | 检索增强生成，通过搜索知识库来补充 Agent 的记忆 |
| GDD | Game Design Document，游戏策划文档 |
| TDD | Tech Design Document，技术设计文档 |

---

## 附录 B：快速启动命令（开发完成后）

```bash
# 1. 安装依赖（只需第一次）
pip install -r requirements.txt

# 2. 启动 AI 游戏开发公司
python backend/main.py

# 3. 在浏览器中打开
# 浏览器访问 http://localhost:8000
```

---

> **文档版本**：v1.2  
> **最后更新**：2026-02-11  
> **更新记录**：
> - v1.1 - 将主力模型从 GPT-4o 切换为 Gemini 3 Pro（100万上下文 + Deep Think + Agentic 优化）  
> - v1.2 - 基于P0-P1测试反馈，添加改进措施：日志系统、重试机制、API迁移计划（第15章）  
> **下一步**：P2 阶段开发（需先完成前置改进任务）
